<html>

<head>
  <meta name="viewport" content="width=device-width, user-scalable=no">

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/ol.css" />

  <script src="https://unpkg.com/d3-fetch@3.0.1/dist/d3-fetch.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@main/dist/en/v7.1.0/ol/dist/ol.js"></script>
  <script src="https://unpkg.com/h3-js@3.7.0"></script>

  <style>
    body {
      padding: 15px;
    }

    @media (max-width: 800px) {
      #container {
        height: 650px;
        grid-template-columns: none !important;
        grid-template-rows: auto 1fr;
      }

      #mapContainer {
        height: auto !important;
      }
    }

    #container {
      display: grid;
      grid-template-columns: 370px 1fr;
    }

    #mapContainer {
      height: 600px;
    }

    #controlContainer {
      margin-top: 10px;
      display: grid;
      grid-column-gap: 10px;
      align-self: center;
    }

    #controlContainer label {
      grid-column: 1 / span 1;
      text-align: end;
    }

    #controlContainer input {
      grid-column: 2 / span 1;
      width: 150px;
    }
  </style>
</head>

<body>
  <h1>Neighborhood Suitability Analysis in Utah</h1>
  <p>
    Suitability analysis allows a user to explore the appropriateness of an area based on a specific set of criteria.
    This application allows the user to select the individual criteria on which to assess and assign a weight to that
    criteria by moving the respective slider bar. When you move a slider bar to the right, the areas on the map that are
    higher in this criteria will be highlighted (i.e., darker hexagons indicate areas of higher suitability).
    Conversely, this map can also be used to explore areas that are less suitable.
  </p>
  <div id="container">
    <div id="controlContainer">
      <label for="childcareWeight">Childcare</label>
      <input id="childcareWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="hospitalWeight">Hospitals</label>
      <input id="hospitalWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="groceryWeight">Grocery and Food</label>
      <input id="groceryWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="libraryWeight">Public Libraries</label>
      <input id="libraryWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="charterschoolsWeight">Charter Schools</label>
      <input id="charterschoolsWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="higheredWeight">Colleges and Universities</label>
      <input id="higheredWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="utarailstationlayerWeight">UTA Light Rail Stations</label>
      <input id="utarailstationlayerWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="utabusstopslayerWeight">UTA Bus Stops</label>
      <input id="utabusstopslayerWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="commcentersWeight">Community Centers</label>
      <input id="commcentersWeight" type="range" min="0" max="1" step="any" value="0" />
      <label for="localparksWeight">Local Parks</label>
      <input id="localparksWeight" type="range" min="0" max="1" step="any" value="0" />
    </div>
    <div id="mapContainer" style="display: none;"></div>
  </div>
  <input id="btnToggleMap" type="button" value="Show Map" />

  <p>This map was created using <a href="https://wiki.openstreetmap.org/wiki/API" rel="nofollow">OSM</a> and the <a
      href="https://github.com/uber/h3">Uber H3 Hexagonal Geospatial Indexing System</a>, <a
      href="https://h3geo.org/docs/core-library/restable" rel="nofollow">resolution 8</a>.</p>

  <p>
    <strong>Data Sources</strong><br>
    Childcare - <a href="https://data.wfrc.org/datasets/utah-child-care-centers" rel="nofollow">WFRC Child Care Centers
      GIS layer</a><br>
    Hospitals - <a href="https://data.wfrc.org/datasets/utah-hospitals" rel="nofollow">WFRC Hospitals GIS layer</a><br>
    Grocery and Food - <a href="https://data.wfrc.org/datasets/utah-grocery-and-food-stores-uda" rel="nofollow">WFRC
      Grocery and Food Stores GIS layer</a><br>
    Public Libraries - <a href="https://opendata.gis.utah.gov/datasets/utah-public-libraries/" rel="nofollow">UGRC
      Public Libraries GIS layer</a><br>
    Charter Schools - <a href="https://opendata.gis.utah.gov/datasets/utah-schools-prek-to-12" rel="nofollow">UGRC
      Schools GIS layer</a><br>
    Colleges and Universities - <a href="https://opendata.gis.utah.gov/datasets/utah-schools-higher-education/"
      rel="nofollow">UGRC Colleges and Universities GIS layer</a><br>
    UTA Light Rail Stations - <a href="https://opendata.gis.utah.gov/datasets/utah-uta-light-rail-stations/"
      rel="nofollow">UTA Light Rail Stations GIS layer</a><br>
    UTA Bus Stops - <a href="https://opendata.gis.utah.gov/datasets/utah-uta-bus-stops-wasatch-front/"
      rel="nofollow">UTA Bus Stops GIS layer</a><br>
    Community Centers - <a href="https://data.wfrc.org/datasets/community-centers/" rel="nofollow">WFRC Community
      Centers GIS layer</a><br>
    Local Parks - <a href="https://opendata.gis.utah.gov/datasets/utah-parks-local" rel="nofollow">UGRC Local Parks GIS
      layer</a>
  </p>

  Built by <a href="https://gis.utah.gov">UGRC</a>

  <script type="module">
    import geojson2h3 from "https://cdn.skypack.dev/geojson2h3@1.0.1";
    // Need to access map object later, so declared at top level scope.
    let map;
    
    // Config
    const config = {
      lng: -111.904,
      lat: 40.719,
      zoom: 9,
      fillOpacity: 0.6,
      colorScale: ["#ffffD9", "#50BAC3", "#1A468A"],
      h3Resolution: 8
    };

    // Utilities
    function normalizeLayer(layer, baseAtZero = false) {
      const hexagons = Object.keys(layer);
      // Pass one, get max
      const max = hexagons.reduce(
        (max, hex) => Math.max(max, layer[hex]),
        -Infinity
      );
      const min = baseAtZero
        ? hexagons.reduce((min, hex) => Math.min(min, layer[hex]), Infinity)
        : 0;
      // Pass two, normalize
      hexagons.forEach((hex) => {
        layer[hex] = (layer[hex] - min) / (max - min);
      });
      return layer;
    }

    function getSliderValue(id) {
      const input = document.getElementById(id);
      const value = parseFloat(input.value);
      console.log(`${id}: ${value}`);

      return value;
    }

    // Transform a kilometer measurement to a k-ring radius
    function kmToRadius(km, resolution) {
      return Math.floor(km / h3.edgeLength(resolution, h3.UNITS.km));
    }

    function bufferPointsLinear(geojson, radius, h3Resolution) {
      const layer = {};
      geojson.features.forEach((feature) => {
        const [lng, lat] = feature.geometry.coordinates;
        const stationIndex = h3.geoToH3(
          lat,
          lng,
          h3Resolution
        );
        // add surrounding multiple surrounding rings, with less weight in each
        const rings = h3.kRingDistances(stationIndex, radius);
        const step = 1 / (radius + 1);
        rings.forEach((ring, distance) => {
          ring.forEach((h3Index) => {
            layer[h3Index] = (layer[h3Index] || 0) + 1 - distance * step;
          });
        });
      });

      return normalizeLayer(layer);
    }

    function interpolateColor(value, stops, colors) {
      const index = stops.findIndex((stop) => value <= stop);
      if (index < 0) {
        return colors[colors.length - 1];
      }
      if (index === 0) {
        return colors[0];
      }
      const startColor = ol.color.asArray(colors[index - 1]);
      const endColor = ol.color.asArray(colors[index]);
      const startStop = stops[index - 1];
      const endStop = stops[index];
      const result = [0, 0, 0, 0]
      for (let i = 0; i < 4; ++i) {
        result[i] = startColor[i] + ((endColor[i] - startColor[i]) * (value - startStop) / (endStop - startStop))
      }
      return ol.color.asString(result);
    }

    let hospitals;
    let childcare;
    let grocery;
    let libraries;
    let highered;
    let utarailstations;
    let commcenters;

    async function getRawData() {
      hospitals = await d3.json(
        "https://opendata.arcgis.com/datasets/39aba645ea9847668df557d1c8dbd666_0.geojson"
      );
      childcare = await d3.json(
        "https://opendata.arcgis.com/datasets/64dd5af56d63483d8bb6841879bb9702_0.geojson"
      );
      grocery = await d3.json(
        "https://opendata.arcgis.com/datasets/81b4eeea6c6c426aa9b165df6eb56870_0.geojson"
      );
      libraries = await d3.json(
        "https://opendata.arcgis.com/datasets/f6cf0c8ef65344b6a6e5ebeaa108f549_0.geojson"
      );
      highered = await d3.json(
        "https://opendata.arcgis.com/datasets/731644a217f445e5a638f9a84a7ada93_0.geojson"
      );
      utarailstations = await d3.json(
        "https://opendata.arcgis.com/datasets/bb8f7bc8871b4a7594bcc037631073e7_0.geojson"
      );
      commcenters = await d3.json(
        "https://opendata.arcgis.com/datasets/25dba734a2f34059bf58143834284d0f_0.geojson"
      );
    }

    async function getData() {
      console.log('getData');

      const h3Resolution = config.h3Resolution;
      // Data Layers
      const hospitallayer = normalizeLayer(
        bufferPointsLinear(hospitals, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const childcarelayer = normalizeLayer(
        bufferPointsLinear(childcare, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const grocerylayer = normalizeLayer(
        bufferPointsLinear(grocery, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const librarylayer = normalizeLayer(
        bufferPointsLinear(libraries, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const higheredlayer = normalizeLayer(
        bufferPointsLinear(highered, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const utarailstationlayer = normalizeLayer(
        bufferPointsLinear(utarailstations, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const commcenterslayer = normalizeLayer(
        bufferPointsLinear(commcenters, kmToRadius(1, h3Resolution), h3Resolution)
      );
      const localparkslayer = normalizeLayer(
        bufferPointsLinear(commcenters, kmToRadius(1, h3Resolution), h3Resolution)
      );


      // Combining Layers
      const mapLayers = [
        { hexagons: hospitallayer, weight: getSliderValue("hospitalWeight") },
        {
          hexagons: childcarelayer,
          weight: getSliderValue("childcareWeight"),
        },
        { hexagons: grocerylayer, weight: getSliderValue("groceryWeight") },
        { hexagons: librarylayer, weight: getSliderValue("libraryWeight") },
        { hexagons: higheredlayer, weight: getSliderValue("higheredWeight") },
        {
          hexagons: commcenterslayer,
          weight: getSliderValue("commcentersWeight"),
        },
        {
          hexagons: utarailstationlayer,
          weight: getSliderValue("utarailstationlayerWeight"),
        },
        {
          hexagons: localparkslayer,
          weight: getSliderValue("localparksWeight"),
        },
      ];

      const combinedLayers = {};
      mapLayers.forEach(({ hexagons, weight }) => {
        Object.keys(hexagons).forEach((hex) => {
          combinedLayers[hex] =
            (combinedLayers[hex] || 0) + hexagons[hex] * weight;
        });
      });

      return combinedLayers;
    }

    // Map Rendering
    function init() {
      console.log("init");

      const outlineColor = 'rgba(0,0,0,0)';
      const style = new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: outlineColor,
          width: 1,
        }),
        fill: new ol.style.Fill(),
      });

      const vectorLayer = new ol.layer.Vector({
        "visible":false,
        style: (feature) => {
          const value = feature.get('value');
          style.getFill().setColor(interpolateColor(value, [0, 0.5, 1], config.colorScale))
          return style;
        },
        opacity: config.fillOpacity,
      });

      map = new ol.Map({
        target: document.getElementById("mapContainer"),
        view: new ol.View({
          center: ol.proj.fromLonLat([config.lng, config.lat]),
          zoom: config.zoom + 1,
        }),
        layers: [
          new ol.layer.Tile({
            source: new ol.source.OSM(),
          }),
          vectorLayer,
        ]
      });
      map.once("rendercomplete", async () => {
        console.log("map load");

        await getRawData();

        refreshMap(vectorLayer);

        const inputs = document.getElementsByTagName("input");
        for (let input of inputs) {
          console.log('hello')
          input.addEventListener("change", () => {
            refreshMap(vectorLayer);
            vectorLayer.setVisible(true); 
          });
        }
      });
    }

    async function refreshMap(vectorLayer) {
      console.log('refreshMap');

      const combinedLayers = await getData();

      renderHexes(vectorLayer, combinedLayers);
    }

    function renderHexes(vectorLayer, hexagons) {
      console.log("renderHexes");

      // Transform the current hexagon map into a GeoJSON object
      const geojson = geojson2h3.h3SetToFeatureCollection(
        Object.keys(hexagons),
        (hex) => ({ value: hexagons[hex] })
      );

      const features = new ol.format.GeoJSON().readFeatures(geojson, {
        featureProjection: 'EPSG:3857'
      });

      const vectorSource = new ol.source.Vector({ features: features });
      vectorLayer.setSource(vectorSource);
    }
    
    function displayMap(){
       var x = document.getElementById("mapContainer");
      if (x.style.display === "none") {
        x.style.display = "block";
        map.updateSize();
      } else {
        x.style.display = "none";
      }
    }
    
    btnToggleMap = document.getElementById("btnToggleMap");
    btnToggleMap.addEventListener("click", displayMap)

    init();
  </script>
</body>

</html>